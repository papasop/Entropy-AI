import Mathlib
noncomputable section
open Int

namespace Residual
set_option autoImplicit false
set_option linter.unusedVariables false
open Classical

------------------------------------------------------------
-- 0. BoolFn 的可判等
------------------------------------------------------------

/-- 二元布尔函数类型。 -/
def BoolFn := Bool → Bool → Bool

/-- 在 classical 公理下，任意类型都有可判等实例。 -/
instance : DecidableEq BoolFn := Classical.decEq _

------------------------------------------------------------
-- 1. Bool → Int
------------------------------------------------------------

def bit (b : Bool) : Int := if b then 1 else 0

@[simp] lemma bit_false : bit false = 0 := rfl
@[simp] lemma bit_true  : bit true  = 1 := rfl

------------------------------------------------------------
-- 2. 能量函数
------------------------------------------------------------

def Energy (lam kap : Int) (a b : Bool) : Int :=
  abs (lam * (bit a + bit b) + kap * (bit a * bit b))

------------------------------------------------------------
-- 3. 门函数
------------------------------------------------------------

def gate (lam kap tau : Int) (a b : Bool) : Bool :=
  decide (tau < Energy lam kap a b)

------------------------------------------------------------
-- 4. XOR / AND / OR / NOT
------------------------------------------------------------

def lamXOR : Int := 20
def kapXOR : Int := -30
def tauXOR : Int := 15

def lamAND : Int := 10
def kapAND : Int := 20
def tauAND : Int := 15

def lamOR  : Int := 15
def kapOR  : Int := 0
def tauOR  : Int := 7

def XORb (a b : Bool) : Bool := gate lamXOR kapXOR tauXOR a b
def ANDb (a b : Bool) : Bool := gate lamAND kapAND tauAND a b
def ORb  (a b : Bool) : Bool := gate lamOR  kapOR  tauOR  a b

def NOTb (a : Bool) : Bool := XORb a true

------------------------------------------------------------
-- 5. 真值表（自动由 decide 完成）
------------------------------------------------------------

lemma XORb_ff : XORb false false = false := by
  unfold XORb gate Energy bit; decide
lemma XORb_ft : XORb false true  = true  := by
  unfold XORb gate Energy bit; decide
lemma XORb_tf : XORb true  false = true  := by
  unfold XORb gate Energy bit; decide
lemma XORb_tt : XORb true  true  = false := by
  unfold XORb gate Energy bit; decide

lemma ANDb_ff : ANDb false false = false := by
  unfold ANDb gate Energy bit; decide
lemma ANDb_ft : ANDb false true  = false := by
  unfold ANDb gate Energy bit; decide
lemma ANDb_tf : ANDb true  false = false := by
  unfold ANDb gate Energy bit; decide
lemma ANDb_tt : ANDb true  true  = true  := by
  unfold ANDb gate Energy bit; decide

lemma ORb_ff : ORb false false = false := by
  unfold ORb gate Energy bit; decide
lemma ORb_ft : ORb false true  = true  := by
  unfold ORb gate Energy bit; decide
lemma ORb_tf : ORb true  false = true  := by
  unfold ORb gate Energy bit; decide
lemma ORb_tt : ORb true  true  = true := by
  unfold ORb gate Energy bit; decide

lemma NOTb_false : NOTb false = true := by
  unfold NOTb XORb gate Energy bit; decide
lemma NOTb_true  : NOTb true  = false := by
  unfold NOTb XORb gate Energy bit; decide

------------------------------------------------------------
-- 6. 抽象能量模型
------------------------------------------------------------

structure EnergyModel where
  lam : Int
  kap : Int
  tau : Int
deriving Repr, DecidableEq

def XORmodel : EnergyModel := { lam := lamXOR, kap := kapXOR, tau := tauXOR }
def ANDmodel : EnergyModel := { lam := lamAND, kap := kapAND, tau := tauAND }
def ORmodel  : EnergyModel := { lam := lamOR,  kap := kapOR,  tau := tauOR }

/-- 模型 `m` 实现布尔函数 `f`：对所有输入 a,b，门的输出等于 f 的输出。 -/
def implements (m : EnergyModel) (f : BoolFn) : Prop :=
  ∀ a b, gate m.lam m.kap m.tau a b = f a b

/-- 在点 (a,b) 处的能量与阈值的距离。 -/
def marginPoint (m : EnergyModel) (a b : Bool) : Nat :=
  Int.natAbs (Energy m.lam m.kap a b - m.tau)

/-- 模型的最小能量裕度：4 个输入点上距离的最小值。 -/
def marginOf (m : EnergyModel) : Nat :=
  let m00 := marginPoint m false false
  let m01 := marginPoint m false true
  let m10 := marginPoint m true  false
  let m11 := marginPoint m true  true
  Nat.min (Nat.min m00 m01) (Nat.min m10 m11)

lemma margin_XOR : marginOf XORmodel = 5 :=
  by simp [marginOf, marginPoint, XORmodel, lamXOR, kapXOR, tauXOR, Energy]

lemma margin_AND : marginOf ANDmodel = 5 :=
  by simp [marginOf, marginPoint, ANDmodel, lamAND, kapAND, tauAND, Energy]

lemma margin_OR : marginOf ORmodel = 7 :=
  by simp [marginOf, marginPoint, ORmodel, lamOR, kapOR, tauOR, Energy]

------------------------------------------------------------
-- 7. “实现”的存在性与唯一性（函数层面）
------------------------------------------------------------

/-- 把能量模型对应的门视为一个 BoolFn。 -/
def gateFn (m : EnergyModel) : BoolFn :=
  fun a b => gate m.lam m.kap m.tau a b

/-- 任意模型都“实现”自己的 gateFn（按定义）。 -/
lemma implements_gateFn (m : EnergyModel) : implements m (gateFn m) := by
  intro a b
  rfl

/-- 若同一个模型 `m` 同时实现 `f` 和 `g`，则二者必然相等。 -/
lemma implements_unique (m : EnergyModel) {f g : BoolFn}
  (hf : implements m f) (hg : implements m g) : f = g := by
  funext a b
  have hf' := hf a b
  have hg' := hg a b
  calc
    f a b = gate m.lam m.kap m.tau a b := by simpa using hf'.symm
    _     = g a b := hg'

/-- 用能量门定义的 XOR/AND/OR 函数别名。 -/
def XORfn : BoolFn := XORb
def ANDfn : BoolFn := ANDb
def ORfn  : BoolFn := ORb

lemma XOR_implements : implements XORmodel XORfn := by
  intro a b
  rfl

lemma AND_implements : implements ANDmodel ANDfn := by
  intro a b
  rfl

lemma OR_implements : implements ORmodel ORfn := by
  intro a b
  rfl

/-- 对于 XORmodel，任何被该模型实现的 BoolFn 都必然等于 XORfn。 -/
lemma XOR_implements_unique (f : BoolFn) (hf : implements XORmodel f) :
  f = XORfn :=
  implements_unique XORmodel hf XOR_implements

/-- 对于 ANDmodel，任何被该模型实现的 BoolFn 都必然等于 ANDfn。 -/
lemma AND_implements_unique (f : BoolFn) (hf : implements ANDmodel f) :
  f = ANDfn :=
  implements_unique ANDmodel hf AND_implements

/-- 对于 ORmodel，任何被该模型实现的 BoolFn 都必然等于 ORfn。 -/
lemma OR_implements_unique (f : BoolFn) (hf : implements ORmodel f) :
  f = ORfn :=
  implements_unique ORmodel hf OR_implements

------------------------------------------------------------
-- 7bis. 极简 cost 与离散动态：收敛到 gateFn
------------------------------------------------------------

/-- 一个极简的“能量代价”：在 gateFn 处为 0，其它函数为 1。 -/
def energyCost (m : EnergyModel) (f : BoolFn) : Nat :=
  if f = gateFn m then 0 else 1

/-- cost 为 0 当且仅当 f = gateFn m（唯一极小值）。 -/
lemma energyCost_zero_iff_eq_gate (m : EnergyModel) (f : BoolFn) :
  energyCost m f = 0 ↔ f = gateFn m := by
  unfold energyCost
  by_cases h : f = gateFn m
  · simp [h]
  · simp [h]

/-- 只要 f ≠ gateFn，代价就是 1，因此严格大于 0。 -/
lemma energyCost_pos_if_ne (m : EnergyModel) (f : BoolFn) (h : f ≠ gateFn m) :
  0 < energyCost m f := by
  unfold energyCost
  simp [h]

/-- 一步离散动态：直接把任何 BoolFn 映射到其能量模型对应的 gateFn。 -/
def stepDyn (m : EnergyModel) (f : BoolFn) : BoolFn :=
  gateFn m

/-- gateFn 在动态下是不动点。 -/
lemma stepDyn_fixpoint (m : EnergyModel) :
  stepDyn m (gateFn m) = gateFn m := rfl

/-- 只要还没到 gateFn，这个一步动态会把 cost 从 1 降为 0。 -/
lemma stepDyn_decreases_cost (m : EnergyModel) (f : BoolFn) (h : f ≠ gateFn m) :
  energyCost m (stepDyn m f) < energyCost m f := by
  unfold stepDyn energyCost
  simp [h]

/-- 多步迭代的离散动态：iterDyn m n f 表示连续做 n 步 stepDyn。 -/
def iterDyn (m : EnergyModel) : Nat → BoolFn → BoolFn
  | 0,     f => f
  | n + 1, f => stepDyn m (iterDyn m n f)

/-- 证明：做 n+1 步，一定已经到 gateFn。 -/
lemma iterDyn_succ (m : EnergyModel) (n : Nat) (f : BoolFn) :
  iterDyn m (n+1) f = gateFn m := by
  cases n <;> simp [iterDyn, stepDyn]

/-- 形式的“收敛定理”：对任何 n ≥ 1，iterDyn m n f = gateFn m。 -/
lemma iterDyn_converges (m : EnergyModel) (f : BoolFn) :
  ∀ n ≥ 1, iterDyn m n f = gateFn m := by
  intro n hn
  cases n with
  | zero =>
      cases hn
  | succ k =>
      simpa using (iterDyn_succ m k f)

------------------------------------------------------------
-- 8. Residual Computing：寄存器机
------------------------------------------------------------

inductive Reg where
  | r0 | r1 | r2 | r3
deriving DecidableEq, Repr

def RegFile := Reg → Bool

def initRegs : RegFile := fun _ => false

def writeReg (r : Reg) (v : Bool) (rf : RegFile) : RegFile :=
  fun r' => if r' = r then v else rf r'

inductive Instr where
  | xor (dst src : Reg)
  | and (dst src : Reg)
  | or  (dst src : Reg)
  | not (dst : Reg)
  | halt
deriving Repr

structure State where
  regs : RegFile
  pc   : Nat

def initState : State := { regs := initRegs, pc := 0 }

def getInstr (prog : List Instr) (pc : Nat) : Option Instr := prog[pc]?

def step (prog : List Instr) (s : State) : State :=
  match getInstr prog s.pc with
  | none => s
  | some Instr.halt => s
  | some (Instr.xor d x) =>
      let v := XORb (s.regs d) (s.regs x)
      { regs := writeReg d v s.regs, pc := s.pc + 1 }
  | some (Instr.and d x) =>
      let v := ANDb (s.regs d) (s.regs x)
      { regs := writeReg d v s.regs, pc := s.pc + 1 }
  | some (Instr.or d x)  =>
      let v := ORb (s.regs d) (s.regs x)
      { regs := writeReg d v s.regs, pc := s.pc + 1 }
  | some (Instr.not d) =>
      let v := NOTb (s.regs d)
      { regs := writeReg d v s.regs, pc := s.pc + 1 }

def run (prog : List Instr) (steps : Nat) : State → State :=
  fun s0 => Nat.recOn steps s0 (fun _ st => step prog st)

------------------------------------------------------------
-- 9. 示例程序：NOT r0
------------------------------------------------------------

def prog_not_r0 : List Instr := [Instr.not Reg.r0]

lemma run_not_r0 :
  (run prog_not_r0 1 initState).regs Reg.r0 = true := by
  simp [run, prog_not_r0, initState, initRegs, step, getInstr, writeReg, NOTb_false]

end Residual
